using DataArrays, DataFrames, JLD, Colors

import Base: complex

export  searchdir,
        s2p,
        feedOutArrayFromDataFrame,
        complexMapSNP,
        complex2dB,
        complex2Phase,
        dB2mag,
        mag2dB,
        assignFromLabel,
        colorArray2FloatArray,
        mergeJLDFileResults,
        ceifk,
        savitsky_golay

"""
    searchdir(path,key)

Search for files matching key in path.\n
__Arg(s)__:\n
`path` - path to search\n
`key` - keyword for file(s) to search\n
__Output(s)__:\n
`files` - list of files in path matching key\n
__Example__:\n
```
juliaFiles = searchdir(path,".jl")
```
"""

function searchdir(path,key)
    return filter(x->contains(x,key), readdir(path))
end

"""
    s2p(file::AbstractString)

Imports arrays of frequency and s parameters from a .s2p file\n
__Arg(s)__:\n
`file` - Touchstone file with extension .s2p\n
__Output(s)__:\n
`frequency`, `S11`, `S21`, `S12`, `S22` - arrays of freqeuency and two port s paramters\n
__Example__:\n
```
f, s11, s21, s12, s22 = s2p("touchstone.s2p")
```
"""
function s2p(file::AbstractString)

    complexNames = [:frequency, :S11, :S21, :S12, :S22]
    data = complex(
        readtable(
        file,
        skipstart = 8,
        header = false,
        separator = ' '
        ),
        complexNames, complexMapSNP(2))
    return feedOutArrayFromDataFrame(data)
end

# function complex2dB(sparam::DataArray)
#     return DataArray(20*log10(abs(Array(sparam))))
# end

"""
    complex(x::DataArray, y::DataArray)

Complex function written for the DataArray type.\n
__Arg(s)__:\n
`x` - DataArray of real parts\n
`y` - DataArray of imaginary parts\n
__Output(s)__:\n
`output` - complex mapped DataArray\n
__Example__:\n
```
complexRand = complex(DataArray(rand(10)), DataArray(1im*rand(10)))
```
"""
function complex(x::DataArray, y::DataArray)
    return DataArray(complex(Array(x), Array(y)))
end

"""
    feedOutArrayFromDataFrame(data::DataFrame)

Reformats DataFrame as a sequence of column arrays output for function ouput.\n
__Arg(s)__:\n
`data` - DataArray of real parts\n
__Output(s)__:\n
`arrayOfArrays` - 1d array containing arrays extracted from DataFrame
"""
function feedOutArrayFromDataFrame(data::DataFrame)
    arrayOfArrays = []
    for i in 1:size(data, 2)
        push!(arrayOfArrays, Array(data[:,i]))
    end
    return arrayOfArrays
end

"""
    complexMapSNP(N)

Complex function map for sNp dataframes. A row with one element equal to one (sum = 1)
corresponds to doing nothing (freqeuency component). A row with two elements (one
of which is equal to one (real part), and the other which is equal to negative two (imaginary part))
so that sum = -1, corresponds to the combination of two seperate complex elements into
one complex number.\n
__Arg(s)__:\n
`N` - integer for a sNp (N port) measurement\n
__Output(s)__:\n
`map` - 2d array
"""
# complex function map for sNp dataframes
function complexMapSNP(N)
    map = round(Int,zeros(1 + N^2, 1 + 2*N^2))
    map[1, 1] = 1 # freqeuncy part
    for i in 2:size(map, 1)
        for j in 2:size(map, 2)
            if j == 2*(i-1)
                map[i, j] = 1 # s param real part
                map[i, j+1] = -2 # s param imag part
            end
        end
    end
    return map
end

"""
    complex(data::DataFrame, outNames::Array{Symbol,1},  cMap::Array{Int, 2})

Complex function written for the DataFrame type.\n
__Arg(s)__:\n
`data` - input of the DataFrame type\n
`outNames` - array of symbols corresponding output data column labels\n
`cMap` - complex mapping for sNp files, generated by ResonatorFit.complexMapSNP(N)\n
__Output(s)__:\n
`dataFrame` - complex mapped DataFrame\n
__Example__:\n
```
complexNames = [:frequency, :S11, :S21, :S12, :S22]
dfOut = complex(dfIn, complexNames, complexMapSNP(2))
```
"""
function complex(data::DataFrame, outNames::Array{Symbol,1},  cMap::Array{Int, 2})
    inNames = names(data)
    # Dimension checking between map and data
    size(cMap, 2) !== size(data, 2)?
    error(string("Dismension mismatch between map and input data. ",
    "Column length of input data for specified map should be ",
    size(cMap, 2), ". Current length is " , size(data, 2))): nothing
    # Dimension checking between map and output names
    size(cMap) !== (maximum(size(outNames)), maximum(size(inNames)))?
    error(string("Dismension mismatch between map and names. Name length for input data should be ",
    size(cMap, 2), ". Current value is " , maximum(size(inNames)) ,
    ". Name length for output data should be ", size(cMap, 1),
    ". Current value is " , maximum(size(outNames)), "."  )) : nothing

    dataFrame = DataFrame()
    nameAssign = [:real, :imag]

    for i in 1:size(cMap,1)
        # frequency part of map, no complex operation
        if countnz(cMap[i,:]) == 1 || countnz(cMap[i,:]) == 2
            if sum(sum(cMap[i,:], 2)) == 1
                for j in 1:size(cMap,2)
                    if cMap[i,j] == 1
                        dataFrame[outNames[i]] = data[inNames[j]]
                    end
                end
            # s parameter part of map, do complex operation
            elseif sum(sum(cMap[i,:], 2)) == -1
                for j in 1:size(cMap,2)
                    if cMap[i,j] == 1
                        nameAssign[1] = inNames[j]
                    elseif cMap[i,j] == -2
                        nameAssign[2] = inNames[j]
                    end
                 end
                dataFrame[outNames[i]] = complex(data[nameAssign[1]], data[nameAssign[2]])
            # unexpected map format
            else
                error("Cannot create a complex number from map! ",
                "Check that there is at least one integer with value 1 ",
                "(real part/no conversion) and optionally one integer with",
                " value -2 (imag part/ conversion) in each row.")
            end
        else
            error("There should only be one or two nonzero elements per row! ")
        end
    end
    return dataFrame
end

"""
    complex2dB(x)

Converts a complex number to a magnitube in dB.\n
__Arg(s)__:\n
`x` - complex number or array\n
__Output(s)__:\n
`db` - magnitude in dB\n
__Example__:\n
```
db = complex2dB([1 + 2im;1 - 2im])
```
"""
function complex2dB(x)
    return 20*log10(abs(x))
end

"""
    complex2Phase(x)

Converts a complex number to a phase relative to the x axis.\n
__Arg(s)__:\n
`x` - complex number or array\n
__Output(s)__:\n
`ph` - phase relative to the x axis\n
__Example__:\n
```
ph = complex2Phase([1 + 2im;1 - 2im])
```
"""
function complex2Phase(x)
    return atan2(imag(x), real(x))
end

"""
    dB2mag(db)

Converts from dB to magnitude.\n
__Arg(s)__:\n
`db` - dB input\n
__Output(s)__:\n
`mag` - magnitude output
"""
function dB2mag(db)
    return 10^(db/20)
end
"""
    mag2dB(mag)

Converts from magnitude to dB.\n
__Arg(s)__:\n
`mag` - mag input\n
__Output(s)__:\n
`db` - dB output
"""
function mag2dB(mag)
    return 20*log10(mag)
end


function assignFromLabel(label::Symbol, dataframe::DataFrame)
    # $label is a symbol so eval($label) actually calls the variable associated
    # with label.
    eval(:($dataframe[$label] = eval($label)))
end

# Converts between the Julia color type and the traditional 3 tuple array
function colorArray2FloatArray{T<:Number}(colorArray::Array{ColorTypes.RGB{T},1})
    arr = zeros(size(colorArray, 1), 3)
    for (idx, color) in enumerate(colorArray)
        arr[idx, 1] = color.r
        arr[idx, 2] = color.g
        arr[idx, 3] = color.b
    end
    return arr
end

# Plots all the fitting traces from the s21FitJLD export file
function mergeJLDFileResults(jldFiles; saveName = "")
    if saveName == ""
        saveName = "jldMergedResults.jld"
    end

    fileKeys = []
    for (idx, file) in enumerate(jldFiles)
        push!(fileKeys,keys(load(file)))
        for key in fileKeys[idx]
            cmd = string(key, "_", idx, " = load(\"", file, "\")[\"", key, "\"]")
            println(cmd)
            eval(parse(cmd))
            if idx > 1
                cmd = string(key, "_", idx, " = vcat(", key, "_", idx, ",", key, "_", idx - 1,")")
                println(cmd)
                eval(parse(cmd))
            end
        end
    end
    global saveArray # Julia made me do this. eval doesn't know about variables outside the for loop!
    saveArray = []
    for key in fileKeys[1]
        cmd = string("push!(saveArray,", "\"", key ,"\", " , key, "_", length(jldFiles) , ")")
        println(cmd)
        eval(parse(cmd))
    end
    save(saveName, saveArray...)
end

"""
    ceifk(x, n)

Complete elliptic integral of the first kind with an approximation of order 2(n -1).
Approximation to integral from: http://www.exstrom.com/math/elliptic/ellipint.html \n
__Arg(s)__:\n
`x` - elliptic integral argument, can be single value or array
`n` - order of approximation
__Output(s)__:\n
`k` - approximate value of the complete elliptic integral of the first kind at `x`
"""
function ceifk(x, n)
    s = 0
    for i in 0:n
        s += binomial(2*i, i).^2.*(x./4).^(2*i)
    end
    return length(x)>1 ? pi/2*sum(s,2) : pi/2*sum(s)
end


"""
    savitsky_golay(x::Array{Float64, 1}, windowSize::Int64, polyOrder::Int64; deriv::Int64=0)

Polynomial smoothing with the Savitsky Golay filters. The Savitzky-Golay is a
type of low-pass filter, particularly suited for smoothing noisy data.
The main idea behind this approach is to make for each point a least-square
fit with a polynomial of high order over a odd-sized window centered at
the point.\n
Orginal author BBN (https://github.com/BBN-Q/Qlab.jl). \n
Theory: http://www.ece.rutgers.edu/~orfanidi/intro2sp/orfanidis-i2sp.pdf\n
Python Example: http://wiki.scipy.org/Cookbook/SavitzkyGolay\n
__Arg(s)__:\n
`x` - the values of the time history of the signal\n
`windowSize` -  size of smoothing window. Must be an odd integer number.\n
`polyOrder` - the order of the polynomial used in the filtering. Must be less then `window_size` - 1.\n
`deriv`- the order of the derivative to compute (default = 0 means only smoothing)\n
__Output(s)__:\n
`ys` - Array of the smoothed signal (or it's n-th derivative)\n
"""
function savitsky_golay(x::Array{Float64, 1}, windowSize::Int64, polyOrder::Int64; deriv::Int64=0)
#Some error checking
@assert isodd(windowSize) "Window size must be an odd integer."
@assert polyOrder < windowSize "Polynomial order must me less than window size."
halfWindow = round(Int,(windowSize-1)/2)
#Setup the S matrix of basis vectors.
S = zeros(windowSize, polyOrder+1)
for ct = 0:polyOrder
	S[:,ct+1] = collect(-halfWindow:halfWindow).^(ct)
end
#Compute the filter coefficients for all orders
#From the scipy code it seems pinv(S) and taking rows should be enough
G = S*pinv(S'*S)
#Slice out the derivative order we want
filterCoeffs = G[:,deriv+1] * factorial(deriv);
#Pad the signal with the endpoints and convolve with filter
paddedX = [x[1]*ones(halfWindow); x; x[end]*ones(halfWindow)]
y = conv(filterCoeffs[end:-1:1], paddedX)
#Return the valid midsection
return y[2*halfWindow+1:end-2*halfWindow]
end

"""
    savitsky_golay(x::Array{Complex{Float64},1}, windowSize::Int64, polyOrder::Int64)

Savitsky Golay filters for complex arrays.
__Arg(s)__:\n
`x` - the complex values of the time history of the signal\n
`windowSize` -  size of smoothing window. Must be an odd integer number.\n
`polyOrder` - the order of the polynomial used in the filtering. Must be less then `window_size` - 1.\n
__Output(s)__:\n
`ys` - complex array of the smoothed signal \n
"""
function savitsky_golay(x::Array{Complex{Float64},1}, windowSize::Int64, polyOrder::Int64)
    return savitsky_golay(real(x), windowSize, polyOrder) + 1im*savitsky_golay(imag(x), windowSize, polyOrder)
end


# Assign a varaible whos name is given by a string s to a value v
# function stringAsVarName(s::String,v::Any)
#          s=symbol(s)
#          @eval (($s) = ($v))
# end

# Automatically extrats variables from a dataframe. This function assigns it's
# column label as a variable to the label's column data
# Mar 24, 2016 THIS DOES NOT WORK
function assignVarFromName(dataframe::DataFrame, print = false)
    global foo = dataframe
    for name in names(foo)
        if print == true
            println(name)
        end
        eval(parse(string("global ", name)))
        eval(parse(string(name, " = foo[:",name,"]")))
        eval(parse(string("println(head(", name, "))")))
        # println(string("global ", name, " = foo[:",name,"]"))
    end

    foo = nothing
end

# Mar 24, 2016 THIS DOES NOT WORK
function dataframeReturnHelper(dataframe::DataFrame, returnType::DataType)
    global foo = dataframe
    returnArray = []
    for name in names(foo)
        println(name)
        println(returnType)
        # eval(parse(string("global ", name)))
        eval(parse(string(name, " = foo[:",name,"]")))
        # eval(parse(string("println(head(", name, "))")))
        # println(string("global ", name, " = foo[:",name,"]"))
        eval(parse(string(name, " = ", returnType, "(",name,")")))
        eval(parse(string("push!(returnArray,", name,")")))
    end
    foo = nothing
    println(returnArray)
    return returnArray
end
