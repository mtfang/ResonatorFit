module ResonatorFit

import Base: complex


using DataArrays, DataFrames, Optim, JLD, PyPlot, Colors

export s2p, complex2dB, complex2Phase, dB2mag, s21Fit, savitsky_golay, s21FitAuto,
        bestFit, searchdir, s21FitPowerSweepJLD, s21FitTimeSweepJLD, plotAllTracesJLD,
        plotAllResultsPowerSweepJLD, plotAllResultsTimeSweepJLD, s21FitFunc, s21FitJLD,
        mergeJLDFileResults, mag2dB, feedOutArrayFromDataFrame, complexMapSNP,
        getQFromFitParams, fitGrade

"""
    searchdir(path,key)

Search for files matching key in path.\n
__Arg(s)__:\n
`path` - path to search\n
`key` - keyword for file(s) to search\n
__Output(s)__:\n
`files` - list of files in path matching key\n
__Example__:\n
```
juliaFiles = searchdir(path,".jl")
```
"""

function searchdir(path,key)
    return filter(x->contains(x,key), readdir(path))
end

"""
    s2p(file::AbstractString)

Imports arrays of frequency and s parameters from a .s2p file\n
__Arg(s)__:\n
`file` - Touchstone file with extension .s2p\n
__Output(s)__:\n
`frequency`, `S11`, `S21`, `S12`, `S22` - arrays of freqeuency and two port s paramters\n
__Example__:\n
```
f, s11, s21, s12, s22 = s2p("touchstone.s2p")
```
"""
function s2p(file::AbstractString)

    complexNames = [:frequency, :S11, :S21, :S12, :S22]
    data = complex(
        readtable(
        file,
        skipstart = 8,
        header = false,
        separator = ' '
        ),
        complexNames, complexMapSNP(2))
    return feedOutArrayFromDataFrame(data)
end

# function complex2dB(sparam::DataArray)
#     return DataArray(20*log10(abs(Array(sparam))))
# end

"""
    complex(x::DataArray, y::DataArray)

Complex function written for the DataArray type.\n
__Arg(s)__:\n
`x` - DataArray of real parts\n
`y` - DataArray of imaginary parts\n
__Output(s)__:\n
`output` - complex mapped DataArray\n
__Example__:\n
```
complexRand = complex(DataArray(rand(10)), DataArray(1im*rand(10)))
```
"""
function complex(x::DataArray, y::DataArray)
    return DataArray(complex(Array(x), Array(y)))
end

"""
    feedOutArrayFromDataFrame(data::DataFrame)

Reformats DataFrame as a sequence of column arrays output for function ouput.\n
__Arg(s)__:\n
`data` - DataArray of real parts\n
__Output(s)__:\n
`arrayOfArrays` - 1d array containing arrays extracted from DataFrame
"""
function feedOutArrayFromDataFrame(data::DataFrame)
    arrayOfArrays = []
    for i in 1:size(data, 2)
        push!(arrayOfArrays, Array(data[:,i]))
    end
    return arrayOfArrays
end

"""
    complexMapSNP(N)

Complex function map for sNp dataframes. A row with one element equal to one (sum = 1)
corresponds to doing nothing (freqeuency component). A row with two elements (one
of which is equal to one (real part), and the other which is equal to negative two (imaginary part))
so that sum = -1, corresponds to the combination of two seperate complex elements into
one complex number.\n
__Arg(s)__:\n
`N` - integer for a sNp (N port) measurement\n
__Output(s)__:\n
`map` - 2d array
"""
# complex function map for sNp dataframes
function complexMapSNP(N)
    map = round(Int,zeros(1 + N^2, 1 + 2*N^2))
    map[1, 1] = 1 # freqeuncy part
    for i in 2:size(map, 1)
        for j in 2:size(map, 2)
            if j == 2*(i-1)
                map[i, j] = 1 # s param real part
                map[i, j+1] = -2 # s param imag part
            end
        end
    end
    return map
end

"""
    complex(data::DataFrame, outNames::Array{Symbol,1},  cMap::Array{Int, 2})

Complex function written for the DataFrame type.\n
__Arg(s)__:\n
`data` - input of the DataFrame type\n
`outNames` - array of symbols corresponding output data column labels\n
`cMap` - complex mapping for sNp files, generated by ResonatorFit.complexMapSNP(N)\n
__Output(s)__:\n
`dataFrame` - complex mapped DataFrame\n
__Example__:\n
```
complexNames = [:frequency, :S11, :S21, :S12, :S22]
dfOut = complex(dfIn, complexNames, complexMapSNP(2))
```
"""
# complex function written for the DataFrame type
function complex(data::DataFrame, outNames::Array{Symbol,1},  cMap::Array{Int, 2})
    inNames = names(data)
    # Dimension checking between map and data
    size(cMap, 2) !== size(data, 2)?
    error(string("Dismension mismatch between map and input data. ",
    "Column length of input data for specified map should be ",
    size(cMap, 2), ". Current length is " , size(data, 2))): nothing
    # Dimension checking between map and output names
    size(cMap) !== (maximum(size(outNames)), maximum(size(inNames)))?
    error(string("Dismension mismatch between map and names. Name length for input data should be ",
    size(cMap, 2), ". Current value is " , maximum(size(inNames)) ,
    ". Name length for output data should be ", size(cMap, 1),
    ". Current value is " , maximum(size(outNames)), "."  )) : nothing

    dataFrame = DataFrame()
    nameAssign = [:real, :imag]

    for i in 1:size(cMap,1)
        # frequency part of map, no complex operation
        if countnz(cMap[i,:]) == 1 || countnz(cMap[i,:]) == 2
            if sum(sum(cMap[i,:], 2)) == 1
                for j in 1:size(cMap,2)
                    if cMap[i,j] == 1
                        dataFrame[outNames[i]] = data[inNames[j]]
                    end
                end
            # s parameter part of map, do complex operation
            elseif sum(sum(cMap[i,:], 2)) == -1
                for j in 1:size(cMap,2)
                    if cMap[i,j] == 1
                        nameAssign[1] = inNames[j]
                    elseif cMap[i,j] == -2
                        nameAssign[2] = inNames[j]
                    end
                 end
                dataFrame[outNames[i]] = complex(data[nameAssign[1]], data[nameAssign[2]])
            # unexpected map format
            else
                error("Cannot create a complex number from map! ",
                "Check that there is at least one integer with value 1 ",
                "(real part/no conversion) and optionally one integer with",
                " value -2 (imag part/ conversion) in each row.")
            end
        else
            error("There should only be one or two nonzero elements per row! ")
        end
    end
    return dataFrame
end

"""
    complex2dB(x)

Converts a complex number to a magnitube in dB.\n
__Arg(s)__:\n
`x` - complex number or array\n
__Output(s)__:\n
`db` - magnitude in dB\n
__Example__:\n
```
db = complex2dB([1 + 2im;1 - 2im])
```
"""
function complex2dB(x)
    return 20*log10(abs(x))
end

"""
    complex2Phase(x)

Converts a complex number to a phase relative to the x axis.\n
__Arg(s)__:\n
`x` - complex number or array\n
__Output(s)__:\n
`ph` - phase relative to the x axis\n
__Example__:\n
```
ph = complex2Phase([1 + 2im;1 - 2im])
```
"""
function complex2Phase(x)
    return atan2(imag(x), real(x))
end

"""
    dB2mag(db)

Converts from dB to magnitude.\n
__Arg(s)__:\n
`db` - dB input\n
__Output(s)__:\n
`mag` - magnitude output
"""
function dB2mag(db)
    return 10^(db/20)
end
"""
    mag2dB(mag)

Converts from magnitude to dB.\n
__Arg(s)__:\n
`mag` - mag input\n
__Output(s)__:\n
`db` - dB output
"""
function mag2dB(mag)
    return 20*log10(mag)
end

# decodes the fitCode as a smoothingFactor and a fitFreqOffset flag
function tryFit(fitCode)
    decoded = readdlm(IOBuffer(fitCode))
    sf = decoded[1]
    ffo = (decoded[2] != 0)
    return sf, ffo
end
# takes the best fit from the DataFrame output
function bestFit(fitResults::DataFrame)
    sort!(fitResults, cols = [:score])
    best = fitResults[1,:]
    # f0, Qi, score, grade = (float(fitResults[:f0][1]), float(fitResults[:Qi][1]), float(fitResults[:score][1]), fitResults[:grade][1])
    return best
end

function assignFromLabel(label::Symbol, dataframe::DataFrame)
    # $label is a symbol so eval($label) actually calls the variable associated
    # with label.
    eval(:($dataframe[$label] = eval($label)))
end

# Converts between the Julia color type and the traditional 3 tuple array
function colorArray2FloatArray{T<:Number}(colorArray::Array{ColorTypes.RGB{T},1})
    arr = zeros(size(colorArray, 1), 3)
    for (idx, color) in enumerate(colorArray)
        arr[idx, 1] = color.r
        arr[idx, 2] = color.g
        arr[idx, 3] = color.b
    end
    return arr
end

# Plots all the fitting traces from the s21FitJLD export file
function plotAllTracesJLD(jldFile)
    traces = load(jldFile)["traces"]
    for i in 1:maximum(size(traces))
        figure()
        plot(Array(traces[:freq][i]), complex2dB(Array(traces[:s21][1i])),"ro")
        plot(Array(traces[:freq][i]), complex2dB(Array(traces[:s21smooth][1i])), "bo")
        plot(Array(traces[:freq][i]), complex2dB(Array(traces[:s21fit][1i])), "g", lw = 3)
    end
end

# Plots all the fitting traces from the s21FitJLD export file
function mergeJLDFileResults(jldFile1, jldFile2; saveName = "")
    results1 = load(jldFile1)["results"]
    traces1 = load(jldFile1)["traces"]
    results2 = load(jldFile2)["results"]
    traces2 = load(jldFile2)["traces"]
    combinedResults = vcat(results1, results2)
    combinedTraces = vcat(traces1, traces2)
    if saveName == ""
        saveName = "jldMergedResults.jld"
    end
    save(saveName, "results", combinedResults, "traces", combinedTraces)
end

# Plots all resonators except ones specified by exlude (indexed by order of frequency)
function plotAllResultsPowerSweepJLD(jldFile; exclude = [])
    results = load(jldFile)["results"]

    sort!(results, cols = (:power, :f0),rev = (true, false))
    resultsGroup = results
    resonators = 11
    numPowers = convert(Int64,maximum(size(resultsGroup))/resonators)
    f0Group = results[:f0][1:11]
    for i in 1:numPowers
        for j in 1:resonators
            resultsGroup[:f0][resonators*(i-1)+j] = f0Group[j]
        end
    end
    sort!(resultsGroup, cols = (:f0, :power),rev = (false, true))

    cs = colorArray2FloatArray(colormap("RdBu", size(results,1)))
    f = resultsGroup[:f0]
    p = resultsGroup[:power]
    q = abs(Array(resultsGroup[:Qi]))*1e6
    figure()
    subplot(111, projection="3d")
    for i in 1:resonators
        if !(i in exclude)
            plot(f[(i-1)*numPowers + 1:i*numPowers]/1e9, p[(i-1)*numPowers + 1:i*numPowers] ,q[(i-1)*numPowers + 1:i*numPowers]/1e6, "o-", label = string(f0Group[i]))
        end
    end
    # scatter(f/1e9, p , zs = q/1e6, c = cs)
    xlabel("Frequency [GHz]")
    ylabel("Power [dBm]")
    zlabel("Internal Quality Factor [Mil]")

    figure()
    for i in 1:resonators
        if !(i in exclude)
            semilogy(p[(i-1)*numPowers + 1:i*numPowers] ,q[(i-1)*numPowers + 1:i*numPowers], "o-", label = string(f0Group[i]))
        end
    end
    xlabel("Power [dBm]")
    ylabel("Internal Quality Factor")
    legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3,
               ncol=2, mode="expand", borderaxespad=0.)

    figure()
    # plot(f,q/1e6, "o")
    for i in 1:resonators
        if !(i in exclude)
            semilogy(f[(i-1)*numPowers + 1:i*numPowers]/1e9 ,q[(i-1)*numPowers + 1:i*numPowers], "o-", label = string(f0Group[i]))
        end
    end
    xlabel("Frequency [GHz]")
    ylabel("Internal Quality Factor")
end


# Plots all resonators except ones specified by exlude (indexed by order of frequency)
function plotAllResultsTimeSweepJLD(jldFile)
    results = load(jldFile)["results"]
    sort!(results, cols = (:timeHours),rev = (false))
    hours = results[:timeHours]
    Qi = results[:Qi]
    f0 = results[:f0]

    figure()
    plot(hours, Qi, "o-")

    xlabel("Time [Hours]")
    ylabel("Internal Quality Factor [Mil]")

    figure()
    plot(hours, f0, "o-")

    xlabel("Time [Hours]")
    ylabel("Resonance Frequency")
    # legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3,
    #            ncol=2, mode="expand", borderaxespad=0.)
end

# reads and fits resonators in the JLD format
function s21FitPowerSweepJLD(file; dataKey = "data", powerKey = "dbm", ifbKey = "ifs", attenVNA = 0,  saveResults = false, saveName = "", iterPerCode = 2000)
    saveName == "" ? saveName = string("fitResults_", basename(file)) : nothing
    res = load(file) # Z: is mapped to nyx
    powers = float(res[powerKey]) - attenVNA
    ifBandwidths = float(res[ifbKey])
    df = DataFrame()
    # powers = linspace(0, -80, 9)
    codeList = ["0 1", "11 1"] # ,
    # codeList = ["0 1"] #
    println(string(0, " of ", size(res[dataKey], 1), " processed"))
    resultIdx = []
    traceIdx = []
    for i in 1:size(res[dataKey], 1)
        for (idx, power) in enumerate(powers)
            dataset = res[dataKey][i,idx]
            freq = Array(dataset[:f])
            s21 = Array(dataset[:S21])
            fitResults, resultIdx, traceIdx = s21FitAuto(freq, s21, power = power, ifBandwidth = ifBandwidths[idx], codes = codeList, iterPerCode = iterPerCode)
            results = bestFit(fitResults)
            df = vcat(df, results)
        end
        println(string(i, " of ", size(res[dataKey], 1), " processed"))
    end
    sort!(df, cols = (:power, :f0),rev = (true, false))
    saveResults? save(saveName, "results", df[resultIdx], "traces", df[traceIdx]) : nothing
    return df[resultIdx]
end

# reads and fits resonators in the JLD format
function s21FitJLD(file; dataKey = "data", saveResults = false, saveName = "", iterPerCode = 2000)
    saveName == "" ? saveName = string("fitResults_", basename(file)) : nothing
    res = load(file) # Z: is mapped to nyx
    df = DataFrame()
    # powers = linspace(0, -80, 9)
    codeList = ["0 1", "11 1"] # ,
    # codeList = ["0 1"] #
    # println(string(0, " of ", size(res[dataKey], 1), " processed"))
    resultIdx = []
    traceIdx = []
    dataset = res[dataKey]
    freq = Array(dataset[:f])
    s21 = Array(dataset[:S21])
    fitResults, resultIdx, traceIdx = s21FitAuto(freq, s21, codes = codeList, iterPerCode = iterPerCode)
    results = bestFit(fitResults)
    df = vcat(df, results)
    sort!(df, cols = (:power, :f0),rev = (true, false))
    saveResults? save(saveName, "results", df[resultIdx], "traces", df[traceIdx]) : nothing
    return df[resultIdx]
end


# reads and fits resonators in the JLD format
function s21FitTimeSweepJLD(file; dataKey = "data", timeKey = "starttime",  saveResults = false, saveName = "", iterPerCode = 2000)
    saveName == "" ? saveName = string("fitResults_", basename(file)) : nothing
    res = load(file) # Z: is mapped to nyx
    df = DataFrame()
    timeHours = (res[timeKey] - res[timeKey][1])/3600
    codeList = ["0 1"] #, "11 1"] # ,
    println(string(0, " of ", size(res[dataKey], 1), " processed"))
    resultIdx = []
    traceIdx = []
    for (idx, hour) in enumerate(timeHours)
        dataset = res[dataKey][idx]
        freq = Array(dataset[:f])
        s21 = Array(dataset[:S21])
        fitResults, resultIdx, traceIdx = s21FitAuto(freq, s21, power = -40, ifBandwidth = 10, codes = codeList, iterPerCode = iterPerCode)
        results = bestFit(fitResults)
        results = join(results, DataFrame(timeHours = hour) , kind = :cross)
        df = vcat(df, results)
        println(string(idx, " of ", size(res[dataKey], 1), " processed"))
    end
    resultIdx = vcat(resultIdx, length(df))
    sort!(df, cols = (:timeHours),rev = (false))
    saveResults? save(saveName, "results", df[resultIdx], "traces", df[traceIdx]) : nothing
    return df[resultIdx]
end


# Tries different fits given a code defining parameters for fit
function s21FitAuto(freq, s21; power = NA, ifBandwidth = NA, codes = ["0 0", "0 1", "51 0", "51 1"], iterPerCode = 1000)
    """
    Automatically runs a set of ftting parameters and outputs a table with fit scoresnh n
    code[1] corresponds to the smoothingFactor parameter in the s21Fit function
    code[2] corresponds to the fitFreqOffset parameter in the s21Fit function
    """
    fitTrails = DataFrame()
    labels = [:code,:f0, :power, :ifBandwidth, :Qi, :dBOffset, :strayInductance, :dipDepth, :phaseOnResonance,
              :score, :grade, :results, :freq, :s21, :s21fit, :s21smooth] #:freqOffset,
    types = [AbstractString, Float64,  Float64,  Float64,  Float64,  Float64,  Float64,  Float64, Float64,
     Float64, AbstractString, Any, Array{Float64, 1}, Array{Complex{Float64},1},
     Array{Complex{Float64},1}, Array{Complex{Float64},1}]
    for (idx, label) in enumerate(labels)
        t = types[idx]
        fitTrails[label] = Array{t}(length(codes))
    end
    # warn(fitTrails)
    for i in 1:length(codes)
        # warn(codes[i])
        sf, ffo = tryFit(codes[i])
        s21fit, s21smooth, results, score = s21Fit(freq, s21,
                smoothingFactor = sf, iter = iterPerCode)
        grade = fitGrade(score, maximum(size(freq)))
        Qi = results.minimum[1]
        dBOffset = results.minimum[2]
        strayInductance = results.minimum[3]
        dipDepth = results.minimum[4]
        f0 = results.minimum[5]
        phaseOnResonance = results.minimum[6]
        code = codes[i]
        ## Gives error that whatever variable I'm using is undefined e.g. f0
        ## Probably a scope problem
        # for label in labels
        #     eval(:(($fitTrails)[$label][i] = eval($label)))
        # end

        # Instead, I have to do it the stupid way
        fitTrails[symbol("code")][i] = code
        fitTrails[symbol("f0")][i] = f0
        fitTrails[symbol("power")][i] = power
        fitTrails[symbol("ifBandwidth")][i] = ifBandwidth
        fitTrails[symbol("Qi")][i] = Qi
        fitTrails[symbol("dBOffset")][i] = dBOffset
        fitTrails[symbol("strayInductance")][i] = strayInductance
        fitTrails[symbol("dipDepth")][i] = dipDepth
        fitTrails[symbol("phaseOnResonance")][i] = phaseOnResonance
        fitTrails[symbol("score")][i] = score
        fitTrails[symbol("grade")][i] = grade
        fitTrails[symbol("results")][i] = results
        fitTrails[symbol("freq")][i]  = freq
        fitTrails[symbol("s21")][i]  = s21
        fitTrails[symbol("s21fit")][i]  = s21fit
        fitTrails[symbol("s21smooth")][i]  = s21smooth
    end
    resultIdx = 2:11
    traceIdx = 13:16
    return fitTrails, resultIdx, traceIdx
end

"""
    s21Fit(freq, s21; pGuess = [0.5], smoothingFactor = 0, iter = 2000, funcTol = 1e-10 )

This function will fit a resonator's S21 transmission response to a fitting
model described in Megrant et. al. ArXiv 1201.3384 (2012). Minimizes
the square residuals using Nelder Mead optimizing provided in `Optim.jl`.\n
__Arg(s)__:\n
`freq` - real array of frequencies\n
`s21` - complex array of the S21 parameters\n
(`pGuess`) - array of length 6 for the initial fit parameter guess. The components
for fitting are as follows:\n
+ Qi/1e6\n
+ dBOffsetFromZero\n
+ strayInductance(nH)\n
+ dipDepth (magnitude)\n
+ f0\n
+ phaseOnResonance\n
(`smoothingFactor`) - smooths the s21 input using Savitzkyâ€“Golay filter with a window size equal to the smoothing factor\n
(`iter`) - maximum number of iterations for convergence before optimization gives upgrade_scalar\n
(`funcTol`) - tolerance for the change in the fit function value between successive iterations\n
__Output(s)__:\n
`s21fit` - the fit s21 function given from the same freqeuency input and optimized parameters\n
`s21smoothed` - smoothed s21 function (if not, then original)\n
`fitResults` - Optim.jl fitting results where calling fitResults.minimum will give optimized paramters\n
`fitScore` - value of fitting function at optimized parameters\n
__Example__:\n
```
s21fit, s21smoothed, fitResults, fitScore = s21Fit(freq, s21)
```
"""
function s21Fit(freq, s21; pGuess = [0.5], smoothingFactor = 0, iter = 2000, funcTol = 1e-10 )
    # Save a copy of orginal s21 before smoothing
    s21org = s21
    # make smoothingFactor an odd integer
    smoothingFactor = round(Int, smoothingFactor)
    isodd(smoothingFactor) ? nothing : (smoothingFactor == 0? nothing : smoothingFactor += 1)
    # smooth s21 if non-zero with polynomial of degree one (linear smoothing)
    smoothingFactor > 0 ? s21 = savitsky_golay(s21, smoothingFactor, 1) : nothing
    """
     The six parameters are as follows:
    1. Qi/1e6
    2. dBOffsetFromZero
    3. strayInductance(nH)
    4. dipDepth (magnitude)
    5. f0
    6. phaseOnResonance
    """
    pSize = 6
    # Make the parameter smaller if too big
    while maximum(size(pGuess, 1)) > pSize
        pop!(pGuess);
    end
    # Make the parameter bigger if too small
    while maximum(size(pGuess, 1)) < pSize
        push!(pGuess, 0)
    end
    # Separate into magnitude and phase
    s21dB = ResonatorFit.complex2dB(s21)
    s21Ph = ResonatorFit.complex2Phase(s21)
    # Get top value of flat area
    s1dBMax = s21dB[indmax(s21dB)]
    # Get resonance value
    s1dBMin = s21dB[indmin(s21dB)]
    # Index of resonance frequency
    f0Idx = indmin(s21dB)
    # Phase at reonance frequency
    # minPhase = s21Ph[f0Idx]  = p[6]
    # Resonance frequency
    pGuess[5] = freq[f0Idx] + pGuess[5]
    # Maximum value of trace to zero
    pGuess[2] = s1dBMax + pGuess[2]
    # Difference in magnitude from top of trace to the bottom of the dip
    pGuess[4] = dB2mag(pGuess[2] - s1dBMin) + pGuess[4]
    # The residual of the dB magnitude for the spectrum
    residualdB(freq, p) = complex2dB(s21) - complex2dB(s21FitFunc(freq,p))
    # The residual of the dB phase for the spectrum
    residualPh(freq, p) = complex2Phase(s21) - complex2Phase(s21FitFunc(freq,p))
    # Errors created from smoothing the orginal data will count against fit
    # Magnitude
    residualSmoothdB = complex2dB(s21org) - complex2dB(s21)
    # Phase
    residualSmoothPh = complex2Phase(s21org) - complex2Phase(s21)
    # The magnitude of the combined residuals
    residualMag(freq, p) = sqrt(residualdB(freq, p).^2 + residualPh(freq, p).^2
        + residualSmoothdB.^2 + residualSmoothPh.^2)
    # Least squares
    rsquared(p) = sum(abs(residualMag(freq, p)).^2)
    # Optimization
    fitResults = optimize(rsquared, pGuess, ftol = funcTol, iterations = iter)
    fitScore = rsquared(fitResults.minimum) # lower the better
    # minimumOutputKey = [Qi/1e6, dBOffsetFromZero, strayInductance(nH), dipDepthMag, f0, phaseOnResonance]
    return s21FitFunc(freq, fitResults.minimum), s21, fitResults, fitScore
end

"""
    s21FitFunc(freq, p)

This function defines the resonance behavior in a parameterized functional form.
The theory for this model can be found in section 2.3.3 and 2.4 of Ben Mazin's thesis\n
__Arg(s)__:\n
`freq` - frequency value or array in Hz\n
`p` -  array of length 6 for fit parameters. The components for fitting are as follows:\n
+ Qi/1e6\n
+ dBOffsetFromZero\n
+ strayInductance(nH)\n
+ dipDepth (magnitude)\n
+ f0\n
+ phaseOnResonance\n
__Output(s)__:\n
`s21val` - the complex value of s21 evaluated at `freq` given fit parameters\n
"""
function s21FitFunc(freq, p)
    # Define the fitting function in a parameterized functional form
    # The theory for this model can be found in section 2.3.3 and 2.4 of Ben Mazin's thesis

    # Difference in s21 between the dip and top of resonance curved,
    # normalized such that top of resonance curve is at 0 dB in units of
    # magnitude, i.e. NOT dB
    s21AdjMin(p) = p[4]
    # Offset between top of resonance curve and 0 dB
    totaloffset(p) = dB2mag(p[2])
    # Add some parasitic series indutance to the transmission line
    Z(freq, p) = 50 + 2im*pi*freq*p[3]/1e9
    # Define a scale factor based on this impedance scaling change
    scalefactor(freq, p) = 50./Z(freq, p)
    # Calcuate the coupling capacitance scaled by the new impedance
    Qc(freq, p) = scalefactor(freq, p)*s21AdjMin(p)*p[1]*1e6/(1 - s21AdjMin(p))
    # Calculate the loaded Q
    Q0(freq, p) = (p[1]*1e6.*Qc(freq, p))./(p[1]*1e6+Qc(freq, p))
    # Some variable I arbitrarily defined
    k(freq, p) = 2im*Q0(freq, p).*(freq - p[5])/p[5]
    # The fitting function in all it's glory
    return (s21AdjMin(p) + k(freq, p)).*exp(1im*p[6])./(1 + k(freq, p))*totaloffset(p)
end

"""
    getQFromFitParams(f0, p)

This function defines the resonance behavior in a parameterized functional form.
The theory for this model can be found in section 2.3.3 and 2.4 of Ben Mazin's thesis.\n
__Arg(s)__:\n
`f0` - resonance frequency\n
`p` -  array of length 6 for fit parameters. The components for fitting are as follows:\n
+ Qi/1e6\n
+ dBOffsetFromZero\n
+ strayInductance(nH)\n
+ dipDepth (magnitude)\n
+ f0\n
+ phaseOnResonance\n
__Output(s)__:\n
`Qc` - coupling Q\n
`Q0` - loaded Q\n
`Qi` - intrinsic Q, equal to `p[1]`
"""
function getQFromFitParams(f0, p)
    s21AdjMin(p) = p[4]
    # Offset between top of resonance curve and 0 dB
    totaloffset(p) = dB2mag(p[2])
    # Add some parasitic series indutance to the transmission line
    Z(f0, p) = 50 + 2im*pi*f0*p[3]/1e9
    # Define a scale factor based on this impedance scaling change
    scalefactor(freq, p) = 50./Z(f0, p)
    # Calcuate the coupling capacitance scaled by the new impedance
    Qc = scalefactor(freq, p)*s21AdjMin(p)*p[1]*1e6/(1 - s21AdjMin(p))
    # Calculate the loaded Q
    Q0 = (p[1]*1e6.*Qc(f0, p))./(p[1]*1e6+Qc(f0, p))
    Qi = p[1]
    return Qc, Q0, Qi
end

"""
    fitGrade(fitScore, pts)

Give an arbitrary grade based on the fit score.\n
__Arg(s)__:\n
`fitScore` - square residual val from minimization function \n
`pts` -  length of fitting function, used so that the grade is normalized to the length of the fit\n
__Output(s)__:\n
`grade` - welcome back to school\n
"""
function fitGrade(fitScore, pts)
    if fitScore/pts < 0.0025
        "A"
    elseif fitScore/pts < 0.01
        "B"
    elseif fitScore/pts < 0.04
        "C"
    elseif fitScore/pts < 0.16
        "D"
    elseif fitScore/pts < 0.32
        "E"
    else
        "F"
    end
end

"""
    savitsky_golay(x::Array{Float64, 1}, windowSize::Int64, polyOrder::Int64; deriv::Int64=0)

Polynomial smoothing with the Savitsky Golay filters. The Savitzky-Golay is a
type of low-pass filter, particularly suited for smoothing noisy data.
The main idea behind this approach is to make for each point a least-square
fit with a polynomial of high order over a odd-sized window centered at
the point.\n
Orginal author BBN (https://github.com/BBN-Q/Qlab.jl). \n
Theory: http://www.ece.rutgers.edu/~orfanidi/intro2sp/orfanidis-i2sp.pdf\n
Python Example: http://wiki.scipy.org/Cookbook/SavitzkyGolay\n
__Arg(s)__:\n
`x` - the values of the time history of the signal\n
`windowSize` -  size of smoothing window. Must be an odd integer number.\n
`polyOrder` - the order of the polynomial used in the filtering. Must be less then `window_size` - 1.\n
`deriv`- the order of the derivative to compute (default = 0 means only smoothing)\n
__Output(s)__:\n
`ys` - Array of the smoothed signal (or it's n-th derivative)\n
"""
function savitsky_golay(x::Array{Float64, 1}, windowSize::Int64, polyOrder::Int64; deriv::Int64=0)
#Some error checking
@assert isodd(windowSize) "Window size must be an odd integer."
@assert polyOrder < windowSize "Polynomial order must me less than window size."
halfWindow = round(Int,(windowSize-1)/2)
#Setup the S matrix of basis vectors.
S = zeros(windowSize, polyOrder+1)
for ct = 0:polyOrder
	S[:,ct+1] = collect(-halfWindow:halfWindow).^(ct)
end
#Compute the filter coefficients for all orders
#From the scipy code it seems pinv(S) and taking rows should be enough
G = S*pinv(S'*S)
#Slice out the derivative order we want
filterCoeffs = G[:,deriv+1] * factorial(deriv);
#Pad the signal with the endpoints and convolve with filter
paddedX = [x[1]*ones(halfWindow); x; x[end]*ones(halfWindow)]
y = conv(filterCoeffs[end:-1:1], paddedX)
#Return the valid midsection
return y[2*halfWindow+1:end-2*halfWindow]
end

"""
    savitsky_golay(x::Array{Complex{Float64},1}, windowSize::Int64, polyOrder::Int64)

Savitsky Golay filters for complex arrays.
__Arg(s)__:\n
`x` - the complex values of the time history of the signal\n
`windowSize` -  size of smoothing window. Must be an odd integer number.\n
`polyOrder` - the order of the polynomial used in the filtering. Must be less then `window_size` - 1.\n
__Output(s)__:\n
`ys` - complex array of the smoothed signal \n
"""
function savitsky_golay(x::Array{Complex{Float64},1}, windowSize::Int64, polyOrder::Int64)
    return savitsky_golay(real(x), windowSize, polyOrder) + 1im*savitsky_golay(imag(x), windowSize, polyOrder)
end


# Assign a varaible whos name is given by a string s to a value v
# function stringAsVarName(s::String,v::Any)
#          s=symbol(s)
#          @eval (($s) = ($v))
# end

# Automatically extrats variables from a dataframe. This function assigns it's
# column label as a variable to the label's column data
# Mar 24, 2016 THIS DOES NOT WORK
function assignVarFromName(dataframe::DataFrame, print = false)
    global foo = dataframe
    for name in names(foo)
        if print == true
            println(name)
        end
        eval(parse(string("global ", name)))
        eval(parse(string(name, " = foo[:",name,"]")))
        eval(parse(string("println(head(", name, "))")))
        # println(string("global ", name, " = foo[:",name,"]"))
    end

    foo = nothing
end

# Mar 24, 2016 THIS DOES NOT WORK
function dataframeReturnHelper(dataframe::DataFrame, returnType::DataType)
    global foo = dataframe
    returnArray = []
    for name in names(foo)
        println(name)
        println(returnType)
        # eval(parse(string("global ", name)))
        eval(parse(string(name, " = foo[:",name,"]")))
        # eval(parse(string("println(head(", name, "))")))
        # println(string("global ", name, " = foo[:",name,"]"))
        eval(parse(string(name, " = ", returnType, "(",name,")")))
        eval(parse(string("push!(returnArray,", name,")")))
    end
    foo = nothing
    println(returnArray)
    return returnArray
end


end # module
