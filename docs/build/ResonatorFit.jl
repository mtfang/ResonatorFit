module ResonatorFit

import Base: complex


using DataArrays, DataFrames, Optim, JLD, PyPlot, Colors

export s2p, complex2dB, complex2Phase, dB2mag, s21Fit, savitsky_golay, s21FitAuto,
        bestFit, searchdir, s21FitPowerSweepJLD, s21FitTimeSweepJLD, plotAllTracesJLD,
        plotAllResultsPowerSweepJLD, plotAllResultsTimeSweepJLD, s21FitFunc, s21FitJLD,
        mergeJLDFileResults

"""
    searchdir(path,key)

Search for files matching key in path.\n
Arg(s):\n
path - path to search\n
key - keyword for file(s) to search\n
Output(s):\n
files - list of files in path matching key\n
Example:\n
f, s11, s21, s12, s22 = s2p("touchstone.s2p")
"""
function searchdir(path,key)
    return filter(x->contains(x,key), readdir(path))
end

"""
    s2p(file::AbstractString)

Imports arrays of frequency and s parameters from a .s2p file\n
Arg(s):\n
file - Touchstone file with extension .s2p\n
Output(s):\n
frequency, S11, S21, S12, S22 - arrays of freqeuency and s paramters\n
Example:\n
f, s11, s21, s12, s22 = s2p("touchstone.s2p")
"""
function s2p(file::AbstractString)

    complexNames = [:frequency, :S11, :S21, :S12, :S22]
    data = complex(
        readtable(
        file,
        skipstart = 8,
        header = false,
        separator = ' '
        ),
        complexNames, complexMapSNP(2))
    return feedOutArrayFromDataFrame(data)
end



# function complex2dB(sparam::DataArray)
#     return DataArray(20*log10(abs(Array(sparam))))
# end

"""
    complex(x::DataArray, y::DataArray)

Complex function written for the DataArray type.\n
Arg(s):\n
x - DataArray of real parts\n
y - DataArray of imaginary parts\n
Output(s):\n
output - complex mapped DataArray\n
Example:\n
complexRand = complex(DataArray(rand(10)), DataArray(1im*rand(10)))
"""

function complex(x::DataArray, y::DataArray)
    return DataArray(complex(Array(x), Array(y)))
end

# reformats DataFrame as a sequence of column arrays output for function ouput
function feedOutArrayFromDataFrame(data::DataFrame)
    output = []
    for i in 1:size(data, 2)
        push!(output, Array(data[:,i]))
    end
    return output
end

# complex function map for sNp dataframes
function complexMapSNP(N)
    map = round(Int,zeros(1 + N^2, 1 + 2*N^2))
    map[1, 1] = 1 # freqeuncy part
    for i in 2:size(map, 1)
        for j in 2:size(map, 2)
            if j == 2*(i-1)
                map[i, j] = 1 # s param real part
                map[i, j+1] = -2 # s param imag part
            end
        end
    end
    return map
end

"""
    complex(data::DataFrame, outNames::Array{Symbol,1},  cMap::Array{Int, 2})

Complex function written for the DataFrame type.\n
Arg(s):\n
data - input of the DataFrame type\n
outNames - array of symbols corresponding output data column labels\n
cMap - complex mapping for sNp files, generated by ResonatorFit.complexMapSNP(N)\n
Output(s):\n
dataFrame - complex mapped DataFrame\n
Example:\n
complexNames = [:frequency, :S11, :S21, :S12, :S22]\n
dfOut = complex(dfIn, complexNames, complexMapSNP(2))
"""
# complex function written for the DataFrame type
function complex(data::DataFrame, outNames::Array{Symbol,1},  cMap::Array{Int, 2})
    inNames = names(data)
    # Dimension checking between map and data
    size(cMap, 2) !== size(data, 2)?
    error(string("Dismension mismatch between map and input data. ",
    "Column length of input data for specified map should be ",
    size(cMap, 2), ". Current length is " , size(data, 2))): nothing
    # Dimension checking between map and output names
    size(cMap) !== (maximum(size(outNames)), maximum(size(inNames)))?
    error(string("Dismension mismatch between map and names. Name length for input data should be ",
    size(cMap, 2), ". Current value is " , maximum(size(inNames)) ,
    ". Name length for output data should be ", size(cMap, 1),
    ". Current value is " , maximum(size(outNames)), "."  )) : nothing

    dataFrame = DataFrame()
    nameAssign = [:real, :imag]

    for i in 1:size(cMap,1)
        # frequency part of map, no complex operation
        if countnz(cMap[i,:]) == 1 || countnz(cMap[i,:]) == 2
            if sum(sum(cMap[i,:], 2)) == 1
                for j in 1:size(cMap,2)
                    if cMap[i,j] == 1
                        dataFrame[outNames[i]] = data[inNames[j]]
                    end
                end
            # s parameter part of map, do complex operation
            elseif sum(sum(cMap[i,:], 2)) == -1
                for j in 1:size(cMap,2)
                    if cMap[i,j] == 1
                        nameAssign[1] = inNames[j]
                    elseif cMap[i,j] == -2
                        nameAssign[2] = inNames[j]
                    end
                 end
                dataFrame[outNames[i]] = complex(data[nameAssign[1]], data[nameAssign[2]])
            # unexpected map format
            else
                error("Cannot create a complex number from map! ",
                "Check that there is at least one integer with value 1 ",
                "(real part/no conversion) and optionally one integer with",
                " value -2 (imag part/ conversion) in each row.")
            end
        else
            error("There should only be one or two nonzero elements per row! ")
        end
    end
    return dataFrame
end

"""
    complex2dB(x)

Converts a complex number to a magnitube in dB.\n
Arg(s):\n
x - complex number or array\n
Output(s):\n
db - magnitude in dB\n
Example:\n
db = complex2dB([1 + 2im;1 - 2im])
"""
function complex2dB(x)
    return 20*log10(abs(x))
end
"""
    complex2Phase(x)

Converts a complex number to a phase relative to the x axis.\n
Arg(s):\n
x - complex number or array\n
Output(s):\n
ph - phase relative to the x axis\n
Example:\n
ph = complex2dB([1 + 2im;1 - 2im])
"""
function complex2Phase(x)
    return atan2(imag(x), real(x))
end

# Converts from dB to magnitude
function dB2mag(db)
    return 10^(db/20)
end

# Converts from magnitude to dB
function mag2dB(mag)
    return 20*log10(mag)
end

# decodes the fitCode as a smoothingFactor and a fitFreqOffset flag
function tryFit(fitCode)
    decoded = readdlm(IOBuffer(fitCode))
    sf = decoded[1]
    ffo = (decoded[2] != 0)
    return sf, ffo
end
# takes the best fit from the DataFrame output
function bestFit(fitResults::DataFrame)
    sort!(fitResults, cols = [:score])
    best = fitResults[1,:]
    # f0, Qi, score, grade = (float(fitResults[:f0][1]), float(fitResults[:Qi][1]), float(fitResults[:score][1]), fitResults[:grade][1])
    return best
end

function assignFromLabel(label::Symbol, dataframe::DataFrame)
    # $label is a symbol so eval($label) actually calls the variable associated
    # with label.
    eval(:($dataframe[$label] = eval($label)))
end

# Converts between the Julia color type and the traditional 3 tuple array
function colorArray2FloatArray{T<:Number}(colorArray::Array{ColorTypes.RGB{T},1})
    arr = zeros(size(colorArray, 1), 3)
    for (idx, color) in enumerate(colorArray)
        arr[idx, 1] = color.r
        arr[idx, 2] = color.g
        arr[idx, 3] = color.b
    end
    return arr
end

# Plots all the fitting traces from the s21FitJLD export file
function plotAllTracesJLD(jldFile)
    traces = load(jldFile)["traces"]
    for i in 1:maximum(size(traces))
        figure()
        plot(Array(traces[:freq][i]), complex2dB(Array(traces[:s21][1i])),"ro")
        plot(Array(traces[:freq][i]), complex2dB(Array(traces[:s21smooth][1i])), "bo")
        plot(Array(traces[:freq][i]), complex2dB(Array(traces[:s21fit][1i])), "g", lw = 3)
    end
end

# Plots all the fitting traces from the s21FitJLD export file
function mergeJLDFileResults(jldFile1, jldFile2; saveName = "")
    results1 = load(jldFile1)["results"]
    traces1 = load(jldFile1)["traces"]
    results2 = load(jldFile2)["results"]
    traces2 = load(jldFile2)["traces"]
    combinedResults = vcat(results1, results2)
    combinedTraces = vcat(traces1, traces2)
    if saveName == ""
        saveName = "jldMergedResults.jld"
    end
    save(saveName, "results", combinedResults, "traces", combinedTraces)
end

# Plots all resonators except ones specified by exlude (indexed by order of frequency)
function plotAllResultsPowerSweepJLD(jldFile; exclude = [])
    results = load(jldFile)["results"]

    sort!(results, cols = (:power, :f0),rev = (true, false))
    resultsGroup = results
    resonators = 11
    numPowers = convert(Int64,maximum(size(resultsGroup))/resonators)
    f0Group = results[:f0][1:11]
    for i in 1:numPowers
        for j in 1:resonators
            resultsGroup[:f0][resonators*(i-1)+j] = f0Group[j]
        end
    end
    sort!(resultsGroup, cols = (:f0, :power),rev = (false, true))

    cs = colorArray2FloatArray(colormap("RdBu", size(results,1)))
    f = resultsGroup[:f0]
    p = resultsGroup[:power]
    q = abs(Array(resultsGroup[:Qi]))*1e6
    figure()
    subplot(111, projection="3d")
    for i in 1:resonators
        if !(i in exclude)
            plot(f[(i-1)*numPowers + 1:i*numPowers]/1e9, p[(i-1)*numPowers + 1:i*numPowers] ,q[(i-1)*numPowers + 1:i*numPowers]/1e6, "o-", label = string(f0Group[i]))
        end
    end
    # scatter(f/1e9, p , zs = q/1e6, c = cs)
    xlabel("Frequency [GHz]")
    ylabel("Power [dBm]")
    zlabel("Internal Quality Factor [Mil]")

    figure()
    for i in 1:resonators
        if !(i in exclude)
            semilogy(p[(i-1)*numPowers + 1:i*numPowers] ,q[(i-1)*numPowers + 1:i*numPowers], "o-", label = string(f0Group[i]))
        end
    end
    xlabel("Power [dBm]")
    ylabel("Internal Quality Factor")
    legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3,
               ncol=2, mode="expand", borderaxespad=0.)

    figure()
    # plot(f,q/1e6, "o")
    for i in 1:resonators
        if !(i in exclude)
            semilogy(f[(i-1)*numPowers + 1:i*numPowers]/1e9 ,q[(i-1)*numPowers + 1:i*numPowers], "o-", label = string(f0Group[i]))
        end
    end
    xlabel("Frequency [GHz]")
    ylabel("Internal Quality Factor")
end


# Plots all resonators except ones specified by exlude (indexed by order of frequency)
function plotAllResultsTimeSweepJLD(jldFile)
    results = load(jldFile)["results"]
    sort!(results, cols = (:timeHours),rev = (false))
    hours = results[:timeHours]
    Qi = results[:Qi]
    f0 = results[:f0]

    figure()
    plot(hours, Qi, "o-")

    xlabel("Time [Hours]")
    ylabel("Internal Quality Factor [Mil]")

    figure()
    plot(hours, f0, "o-")

    xlabel("Time [Hours]")
    ylabel("Resonance Frequency")
    # legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3,
    #            ncol=2, mode="expand", borderaxespad=0.)
end

# reads and fits resonators in the JLD format
function s21FitPowerSweepJLD(file; dataKey = "data", powerKey = "dbm", ifbKey = "ifs", attenVNA = 0,  saveResults = false, saveName = "", iterPerCode = 2000)
    saveName == "" ? saveName = string("fitResults_", basename(file)) : nothing
    res = load(file) # Z: is mapped to nyx
    powers = float(res[powerKey]) - attenVNA
    ifBandwidths = float(res[ifbKey])
    df = DataFrame()
    # powers = linspace(0, -80, 9)
    codeList = ["0 1", "11 1"] # ,
    # codeList = ["0 1"] #
    println(string(0, " of ", size(res[dataKey], 1), " processed"))
    resultIdx = []
    traceIdx = []
    for i in 1:size(res[dataKey], 1)
        for (idx, power) in enumerate(powers)
            dataset = res[dataKey][i,idx]
            freq = Array(dataset[:f])
            s21 = Array(dataset[:S21])
            fitResults, resultIdx, traceIdx = s21FitAuto(freq, s21, power = power, ifBandwidth = ifBandwidths[idx], codes = codeList, iterPerCode = iterPerCode)
            results = bestFit(fitResults)
            df = vcat(df, results)
        end
        println(string(i, " of ", size(res[dataKey], 1), " processed"))
    end
    sort!(df, cols = (:power, :f0),rev = (true, false))
    saveResults? save(saveName, "results", df[resultIdx], "traces", df[traceIdx]) : nothing
    return df[resultIdx]
end

# reads and fits resonators in the JLD format
function s21FitJLD(file; dataKey = "data", saveResults = false, saveName = "", iterPerCode = 2000)
    saveName == "" ? saveName = string("fitResults_", basename(file)) : nothing
    res = load(file) # Z: is mapped to nyx
    df = DataFrame()
    # powers = linspace(0, -80, 9)
    codeList = ["0 1", "11 1"] # ,
    # codeList = ["0 1"] #
    # println(string(0, " of ", size(res[dataKey], 1), " processed"))
    resultIdx = []
    traceIdx = []
    dataset = res[dataKey]
    freq = Array(dataset[:f])
    s21 = Array(dataset[:S21])
    fitResults, resultIdx, traceIdx = s21FitAuto(freq, s21, codes = codeList, iterPerCode = iterPerCode)
    results = bestFit(fitResults)
    df = vcat(df, results)
    sort!(df, cols = (:power, :f0),rev = (true, false))
    saveResults? save(saveName, "results", df[resultIdx], "traces", df[traceIdx]) : nothing
    return df[resultIdx]
end


# reads and fits resonators in the JLD format
function s21FitTimeSweepJLD(file; dataKey = "data", timeKey = "starttime",  saveResults = false, saveName = "", iterPerCode = 2000)
    saveName == "" ? saveName = string("fitResults_", basename(file)) : nothing
    res = load(file) # Z: is mapped to nyx
    df = DataFrame()
    timeHours = (res[timeKey] - res[timeKey][1])/3600
    codeList = ["0 1"] #, "11 1"] # ,
    println(string(0, " of ", size(res[dataKey], 1), " processed"))
    resultIdx = []
    traceIdx = []
    for (idx, hour) in enumerate(timeHours)
        dataset = res[dataKey][idx]
        freq = Array(dataset[:f])
        s21 = Array(dataset[:S21])
        fitResults, resultIdx, traceIdx = s21FitAuto(freq, s21, power = -40, ifBandwidth = 10, codes = codeList, iterPerCode = iterPerCode)
        results = bestFit(fitResults)
        results = join(results, DataFrame(timeHours = hour) , kind = :cross)
        df = vcat(df, results)
        println(string(idx, " of ", size(res[dataKey], 1), " processed"))
    end
    resultIdx = vcat(resultIdx, length(df))
    sort!(df, cols = (:timeHours),rev = (false))
    saveResults? save(saveName, "results", df[resultIdx], "traces", df[traceIdx]) : nothing
    return df[resultIdx]
end


# Tries different fits given a code defining parameters for fit
function s21FitAuto(freq, s21; power = NA, ifBandwidth = NA, codes = ["0 0", "0 1", "51 0", "51 1"], iterPerCode = 1000)
    """
    Automatically runs a set of ftting parameters and outputs a table with fit scoresnh n
    code[1] corresponds to the smoothingFactor parameter in the s21Fit function
    code[2] corresponds to the fitFreqOffset parameter in the s21Fit function
    """
    fitTrails = DataFrame()
    labels = [:code,:f0, :power, :ifBandwidth, :Qi, :dBOffset, :strayInductance, :dipDepth, :phaseOnResonance,
              :score, :grade, :results, :freq, :s21, :s21fit, :s21smooth] #:freqOffset,
    types = [AbstractString, Float64,  Float64,  Float64,  Float64,  Float64,  Float64,  Float64, Float64,
     Float64, AbstractString, Any, Array{Float64, 1}, Array{Complex{Float64},1},
     Array{Complex{Float64},1}, Array{Complex{Float64},1}]
    for (idx, label) in enumerate(labels)
        t = types[idx]
        fitTrails[label] = Array{t}(length(codes))
    end
    # warn(fitTrails)
    for i in 1:length(codes)
        # warn(codes[i])
        sf, ffo = tryFit(codes[i])
        s21fit, s21smooth, results, score = s21Fit(freq, s21,
                smoothingFactor = sf, iter = iterPerCode)
        grade = fitGrade(score, maximum(size(freq)))
        Qi = results.minimum[1]
        dBOffset = results.minimum[2]
        strayInductance = results.minimum[3]
        dipDepth = results.minimum[4]
        f0 = results.minimum[5]
        phaseOnResonance = results.minimum[6]
        code = codes[i]
        ## Gives error that whatever variable I'm using is undefined e.g. f0
        ## Probably a scope problem
        # for label in labels
        #     eval(:(($fitTrails)[$label][i] = eval($label)))
        # end

        # Instead, I have to do it the stupid way
        fitTrails[symbol("code")][i] = code
        fitTrails[symbol("f0")][i] = f0
        fitTrails[symbol("power")][i] = power
        fitTrails[symbol("ifBandwidth")][i] = ifBandwidth
        fitTrails[symbol("Qi")][i] = Qi
        fitTrails[symbol("dBOffset")][i] = dBOffset
        fitTrails[symbol("strayInductance")][i] = strayInductance
        fitTrails[symbol("dipDepth")][i] = dipDepth
        fitTrails[symbol("phaseOnResonance")][i] = phaseOnResonance
        fitTrails[symbol("score")][i] = score
        fitTrails[symbol("grade")][i] = grade
        fitTrails[symbol("results")][i] = results
        fitTrails[symbol("freq")][i]  = freq
        fitTrails[symbol("s21")][i]  = s21
        fitTrails[symbol("s21fit")][i]  = s21fit
        fitTrails[symbol("s21smooth")][i]  = s21smooth
    end
    resultIdx = 2:11
    traceIdx = 13:16
    return fitTrails, resultIdx, traceIdx
end

# Fits resonator data to a prescribed model using least squares + Nelder Mead
function s21Fit(freq, s21; pGuess = [0.5], smoothingFactor = 0, iter = 2000, method = NelderMead())
    """
    This function will fit a resonator's S21 transmission response to a fitting
    model described in Megrant et. al. ArXiv 1201.3384 (2012). Minimizes
    the square residuals. The optimized output parameters are as follows:
     - Qi/1e6
     - dBOffsetFromZero
     - strayInductance(nH)
     - dipDepth (magnitude)
     - f0
     - phaseOnResonance
    """

    s21org = s21
    # make smoothingFactor an odd integer
    smoothingFactor = round(Int, smoothingFactor)
    isodd(smoothingFactor) ? nothing : (smoothingFactor == 0? nothing : smoothingFactor += 1)
    # smooth s21 if non-zero with polynomial of degree one (linear smoothing)
    smoothingFactor > 0 ? s21 = savitsky_golay(s21, smoothingFactor, 1) : nothing

    pSize = 6
    # Make the parameter smaller if too big
    while maximum(size(pGuess, 1)) > pSize
        pop!(pGuess);
    end
    # Make the parameter bigger if too small
    while maximum(size(pGuess, 1)) < pSize
        push!(pGuess, 0)
    end

    # Separate into magnitude and phase
    s21dB = ResonatorFit.complex2dB(s21)
    s21Ph = ResonatorFit.complex2Phase(s21)
    # Get top value of flat area
    s1dBMax = s21dB[indmax(s21dB)]
    # Get resonance value
    s1dBMin = s21dB[indmin(s21dB)]
    # Index of resonance frequency
    f0Idx = indmin(s21dB)
    # Phase at reonance frequency
    # minPhase = s21Ph[f0Idx]  = p[6]
    # Resonance frequency
    pGuess[5] = freq[f0Idx] + pGuess[5]
    # Maximum value of trace to zero
    pGuess[2] = s1dBMax + pGuess[2]
    # Difference in magnitude from top of trace to the bottom of the dip
    pGuess[4] = dB2mag(pGuess[2] - s1dBMin) + pGuess[4]

    #
    # # Define the fitting function in a parameterized functional form
    # # The theory for this model can be found in section 2.3.3 and 2.4 of Ben Mazin's thesis
    # # Zero offset at flat region of spectrum
    # totaloffsetdB(p) =  s1dBMax + p[2]
    # # Convert from dB
    # totaloffset(p) = dB2mag(totaloffsetdB(p))
    # # Adjust the minimum value from the offset
    # s21AdjMin(p) = dB2mag(s21dB[f0Idx] - totaloffsetdB(p)) + p[4]
    # # Add some parasitic series indutance to the transmission line
    # Z(freq, p) = 50 + 2im*pi*freq*p[3]/1e9
    # # Define a scale factor based on this impedance scaling change
    # scalefactor(freq, p) = 50./Z(freq, p)
    # # Calcuate the coupling capacitance scaled by the new impedance
    # Qc(freq, p) = scalefactor(freq, p)*s21AdjMin(p)*p[1]*1e6/(1 - s21AdjMin(p))
    # # Calculate the loaded Q
    # Q0(freq, p) = (p[1]*1e6.*Qc(freq, p))./(p[1]*1e6+Qc(freq, p))
    # # Some variable I arbitrarily defined
    #  ? k(freq, p) = 2im*Q0(freq, p).*(freq - f0(p))/f0(p) : k(freq, p) = 2im*Q0(freq, p).*(freq - f0)/f0
    # # The fitting function in all it's glory
    # s21fit(freq, p) = (s21AdjMin(p) + k(freq, p)).*exp(1im*minPhase)./(1 + k(freq, p))*totaloffset(p)
    # The residual of the dB magnitude for the spectrum
    residualdB(freq, p) = complex2dB(s21) - complex2dB(s21FitFunc(freq,p))
    # The residual of the dB phase for the spectrum
    residualPh(freq, p) = complex2Phase(s21) - complex2Phase(s21FitFunc(freq,p))
    # Errors created from smoothing the orginal data will count against fit
    residualSmoothdB = complex2dB(s21org) - complex2dB(s21)
    residualSmoothPh = complex2Phase(s21org) - complex2Phase(s21)
    # The magnitude of the combined residuals
    residualMag(freq, p) = sqrt(residualdB(freq, p).^2 + residualPh(freq, p).^2
        + residualSmoothdB.^2 + residualSmoothPh.^2) # residualdB(freq, p) #
    # Least squares
    rsquared(p) = sum(abs(residualMag(freq, p)).^2)
    # Optimization
    funcTol = 1e-10 # Change in the fit function value between successive iterations
    fitResults = optimize(rsquared, pGuess, method = method, ftol = funcTol, iterations = iter)
    fitScore = rsquared(fitResults.minimum) # lower the better


    # fitFreqOffset ? nothing : push!(fitResults.minimum, 0)
    # freq = quickLinearInterp(freq, freqInterpFactor)


    # minimumOutputKey = [Qi/1e6, dBOffsetFromZero, strayInductance(nH), dipDepthMag, f0, phaseOnResonance]
    return s21FitFunc(freq, fitResults.minimum), s21, fitResults, fitScore
end

function s21FitFunc(freq, p)
    # Define the fitting function in a parameterized functional form
    # The theory for this model can be found in section 2.3.3 and 2.4 of Ben Mazin's thesis
    s21AdjMin(p) = p[4]
    totaloffset(p) = dB2mag(p[2])
    # Add some parasitic series indutance to the transmission line
    Z(freq, p) = 50 + 2im*pi*freq*p[3]/1e9
    # Define a scale factor based on this impedance scaling change
    scalefactor(freq, p) = 50./Z(freq, p)
    # Calcuate the coupling capacitance scaled by the new impedance
    Qc(freq, p) = scalefactor(freq, p)*s21AdjMin(p)*p[1]*1e6/(1 - s21AdjMin(p))
    # Calculate the loaded Q
    Q0(freq, p) = (p[1]*1e6.*Qc(freq, p))./(p[1]*1e6+Qc(freq, p))
    # Some variable I arbitrarily defined
    k(freq, p) = 2im*Q0(freq, p).*(freq - p[5])/p[5]
    # The fitting function in all it's glory
    return (s21AdjMin(p) + k(freq, p)).*exp(1im*p[6])./(1 + k(freq, p))*totaloffset(p)
end


function quickLinearInterp(x, interpFactor)
    return Array(linspace(minimum(x), maximum(x), interpFactor*(length(x) - 1) + 1))
end
# Give an arbitrary score to the fit
function fitGrade(fitScore, pts)
    if fitScore/pts < 0.0025
        "A"
    elseif fitScore/pts < 0.01
        "B"
    elseif fitScore/pts < 0.04
        "C"
    elseif fitScore/pts < 0.16
        "D"
    elseif fitScore/pts < 0.32
        "E"
    else
        "F"
    end
end
# Polynomial smoothing with the Savitsky Golay filters
# Orginal author BBN (https://github.com/BBN-Q/Qlab.jl)
# Modified by Michael Fang to update depreciated functions
# Sources
# ---------
# Theory: http://www.ece.rutgers.edu/~orfanidi/intro2sp/orfanidis-i2sp.pdf
# Python Example: http://wiki.scipy.org/Cookbook/SavitzkyGolay

function savitsky_golay(x::Array{Float64, 1}, windowSize::Int64, polyOrder::Int64; deriv::Int64=0)

#Some error checking
@assert isodd(windowSize) "Window size must be an odd integer."
@assert polyOrder < windowSize "Polynomial order must me less than window size."

halfWindow = round(Int,(windowSize-1)/2)

#Setup the S matrix of basis vectors.
S = zeros(windowSize, polyOrder+1)
for ct = 0:polyOrder
	S[:,ct+1] = collect(-halfWindow:halfWindow).^(ct)
end

#Compute the filter coefficients for all orders
#From the scipy code it seems pinv(S) and taking rows should be enough
G = S*pinv(S'*S)

#Slice out the derivative order we want
filterCoeffs = G[:,deriv+1] * factorial(deriv);

#Pad the signal with the endpoints and convolve with filter
paddedX = [x[1]*ones(halfWindow); x; x[end]*ones(halfWindow)]
y = conv(filterCoeffs[end:-1:1], paddedX)

#Return the valid midsection
return y[2*halfWindow+1:end-2*halfWindow]

end

# complex version
function savitsky_golay(x::Array{Complex{Float64},1}, windowSize::Int64, polyOrder::Int64)
    return savitsky_golay(real(x), windowSize, polyOrder) + 1im*savitsky_golay(imag(x), windowSize, polyOrder)
end

# Assign a varaible whos name is given by a string s to a value v
# function stringAsVarName(s::String,v::Any)
#          s=symbol(s)
#          @eval (($s) = ($v))
# end

# Automatically extrats variables from a dataframe. This function assigns it's
# column label as a variable to the label's column data
# Mar 24, 2016 THIS DOES NOT WORK
function assignVarFromName(dataframe::DataFrame, print = false)
    global foo = dataframe
    for name in names(foo)
        if print == true
            println(name)
        end
        eval(parse(string("global ", name)))
        eval(parse(string(name, " = foo[:",name,"]")))
        eval(parse(string("println(head(", name, "))")))
        # println(string("global ", name, " = foo[:",name,"]"))
    end

    foo = nothing
end

# Mar 24, 2016 THIS DOES NOT WORK
function dataframeReturnHelper(dataframe::DataFrame, returnType::DataType)
    global foo = dataframe
    returnArray = []
    for name in names(foo)
        println(name)
        println(returnType)
        # eval(parse(string("global ", name)))
        eval(parse(string(name, " = foo[:",name,"]")))
        # eval(parse(string("println(head(", name, "))")))
        # println(string("global ", name, " = foo[:",name,"]"))
        eval(parse(string(name, " = ", returnType, "(",name,")")))
        eval(parse(string("push!(returnArray,", name,")")))
    end
    foo = nothing
    println(returnArray)
    return returnArray
end


end # module
